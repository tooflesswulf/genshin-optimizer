(()=>{"use strict";var e,t,n={40580:(e,t,n)=>{n.d(t,{Gd:()=>o,aD:()=>a,uW:()=>r});var s=n(97797);function a(e,t,n){const s=new Set,a=new Set;e.forEach((function e(r){a.has(r)||(s.has(r)?console.error("Found cyclical dependency during formula traversal"):(s.add(r),t(r),r.operands.forEach(e),n(r),s.delete(r),a.add(r)))}))}function r(e,t,n){const a=new Set,r=new Map,o=new Map;function c(e){let l=r.get(e);if(l)return l;l=t(e);let u=o.get(l);return u||(a.has(l)?(console.error("Found cyclical dependency during formula mapping"),(0,s.a9)(NaN)):(a.add(l),u=n(function(e){const t=e.operands.map(c);return i(t,e.operands)?e:Object.assign({},e,{operands:t})}(l),e),a.delete(l),r.set(e,u),o.set(l,u),u))}const l=e.map(c);return i(l,e)?e:l}function o(e,t,n){const s=new Map;function a(e,t){let r=s.get(t);r||s.set(t,r=[new Set,new Map]);const[o,i]=r,c=i.get(e);if(c)return c;if(o.has(e))throw new Error("Found cyclical dependency during formula mapping");o.add(e);const l=n(e,t,a);return i.set(e,l),o.delete(e),l}return e.map((e=>a(e,t)))}function i(e,t){return void 0===e?void 0===t:void 0!==t&&(e.length===t.length&&e.every(((e,n)=>e===t[n])))}},30597:(e,t,n)=>{n.d(t,{CG:()=>h,I3:()=>u,aj:()=>i,tL:()=>l});var s=n(41015),a=n(40580),r=n(97797);const o={min:e=>Math.min(...e),max:e=>Math.max(...e),add:e=>e.reduce(((e,t)=>e+t),0),mul:e=>e.reduce(((e,t)=>e*t),1)},i=Object.assign({},o,{res:([e])=>e<0?1-e/2:e>=.75?1/(4*e+1):1-e,sum_frac:e=>e[0]/e.reduce(((e,t)=>e+t)),threshold:([e,t,n,s])=>e>=t?n:s}),c=new Set(Object.keys(o));function l(e,t,n=(e=>!1)){let s=h(e,t,n);return s=d(s),p(s)}function u(e,t,n,r){let o='\n"use strict";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0',i=1;const c=new Map;return(0,a.aD)(e,(e=>{}),(e=>{const{operation:a,operands:l}=e,u="x"+i++,d=l.map((e=>c.get(e)));switch(c.set(e,u),a){case"read":{const s=n(e);let a=new Array(r).fill(null).map(((e,t)=>`(b[${t}].values["${s}"] ?? 0)`));t[s]&&0!==t[s]&&(a=[t[s].toString(),...a]),o+=`,${u}=${a.join("+")}`;break}case"const":c.set(e,`(${e.value})`);break;case"add":case"mul":o+=`,${u}=${d.join("add"===a?"+":"*")}`;break;case"min":case"max":o+=`,${u}=Math.${a}(${d})`;break;case"threshold":{const[e,t,n,s]=d;o+=`,${u}=(${e}>=${t})?${n}:${s}`;break}case"res":o+=`,${u}=res(${d[0]})`;break;case"sum_frac":o+=`,${u}=${d[0]}/(${d[0]}+${d[1]})`;break;default:(0,s.UT)(a)}})),o+=`;\nreturn [${e.map((e=>c.get(e)))}]`,new Function("b",o)}function d(e){return(0,a.uW)(e,(e=>e),(e=>{let t=e;if(c.has(e.operation)){const n=e,{operation:s}=n;let a=!1;const r=n.operands.flatMap((e=>e.operation===s?(a=!0,e.operands):[e]));t=a?Object.assign({},n,{operands:r}):n}return t}))}function p(e){function t(e){const t=new Map;for(const s of e){var n;t.set(s,(null!=(n=t.get(s))?n:0)+1)}return t}const n={common:{counts:new Map,formulas:new Set,operation:"add"}};for(;;){let r;const i={operation:n.common.operation,operands:(s=n.common.counts,[...s].flatMap((([e,t])=>Array(t).fill(e))))},l=new Map;for(const e of Object.keys(o))l.set(e,[]);if(e=(0,a.uW)(e,(e=>{if(n.common.formulas.has(e)){const t=e,s=new Map(n.common.counts),a=t.operands.filter((e=>{const t=s.get(e);return!t||(s.set(e,t-1),!1)}));return a.length?(a.push(i),Object.assign({},t,{operands:a})):i}return e}),(e=>{if(!c.has(e.operation))return e;const n=e;if(r){if(r.operation===n.operation){const e=t(n.operands),a=new Map,o=r.counts;let i=0;for(const[t,n]of e.entries()){var s;const e=Math.min(n,null!=(s=o.get(t))?s:0);e?(a.set(t,e),i+=e):a.delete(t)}i>1&&(r.counts=a,r.formulas.add(n))}}else{const e=l.get(n.operation),s=t(n.operands);for(const[t,o]of e){let e=0;const i=new Map;for(const[t,n]of o.entries()){var a;const r=Math.min(n,null!=(a=s.get(t))?a:0);r&&(i.set(t,r),e+=r)}if(e>1){r={counts:i,formulas:new Set([n,t]),operation:n.operation},l.clear();break}}r||e.push([n,s])}return n})),!r)break;n.common=r}var s;return e}function h(e,t,n=(e=>!1)){const o={data:[],processed:new Map},c=new Map([[o,new Map]]),l={data:[t],processed:new Map};return c.set(l,new Map),c.get(o).set(t,l),(0,a.Gd)(e,l,((e,t,a)=>{var l;const{operation:u}=e,d=(e,t)=>a(e,t),p=(e,t)=>a(e,t);let h;switch(u){case"const":h=e;break;case"add":case"mul":case"max":case"min":const g=i[u],b=[],w=e.operands.filter((e=>{const n=d(e,t);return"const"!==n.operation||(b.push(n.value),!1)})).map((e=>d(e,t))),x=g(b);if(isFinite(x)){if("mul"===u&&0===x){h=(0,r.a9)(x);break}}else if("mul"!==u&&("max"!==u||x>0)&&("min"!==u||x<0)){h=(0,r.a9)(x);break}x!==g([])&&w.push((0,r.a9)(x)),h=w.length<=1?null!=(l=w[0])?l:(0,r.a9)(g([])):{operation:u,operands:w};break;case"res":case"sum_frac":{const n=e.operands.map((e=>d(e,t))),s=i[u];h=n.every((e=>"const"===e.operation))?(0,r.a9)(s(n.map((e=>e.value)))):Object.assign({},e,{operands:n});break}case"lookup":{const n=p(e.operands[0],t);if("const"===n.operation){var f;const s=null!=(f=e.table[n.value])?f:e.operands[1];if(s){h=a(s,t);break}}throw new Error(`Unsupported ${u} node while folding`)}case"prio":{const n=e.operands.find((e=>{const n=p(e,t);if("const"!==n.operation)throw new Error(`Unsupported ${u} node while folding`);return void 0!==n.value}));h=n?p(n,t):(0,r.a9)(void 0);break}case"small":{var m;let n;for(const s of e.operands){var v;const e=p(s,t);if("const"!==e.operation)throw new Error(`Unsupported ${u} node while folding`);(void 0===(null==(v=n)?void 0:v.value)||void 0!==e.value&&e.value<n.value)&&(n=e)}h=null!=(m=n)?m:(0,r.a9)(void 0);break}case"match":{const[n,s,r,o]=e.operands.map((e=>a(e,t)));if("const"!==n.operation||"const"!==s.operation)throw new Error(`Unsupported ${u} node while folding`);h=n.value===s.value?r:o;break}case"threshold":{const[n,s,r,o]=e.operands.map((e=>a(e,t)));h="const"===r.operation&&"const"===o.operation&&r.value===o.value?r:"const"===n.operation&&"const"===s.operation?n.value>=s.value?r:o:Object.assign({},e,{operands:[n,s,r,o]});break}case"subscript":{const n=d(e.operands[0],t);if("const"!==n.operation)throw new Error("Found non-constant subscript node while folding");h=(0,r.a9)(e.list[n.value]);break}case"read":{const o=t.data.map((t=>(0,s.Hm)(t,e.path))).filter((e=>e));if(0===o.length)if(n(e)){const{accu:t}=e;h=void 0===t||"small"===t?"string"===e.type?(0,r.a9)(void 0):(0,r.a9)(NaN):(0,r.a9)(i[t]([]))}else h=e;else h=void 0===e.accu||1===o.length?a(o[o.length-1],t):a({operation:e.accu,operands:o},t);break}case"data":{e.reset&&(t=o);const n=c.get(t);let s=n.get(e.data);s||(s={data:[...t.data,e.data],processed:new Map},c.set(s,new Map),n.set(e.data,s)),h=a(e.operands[0],s);break}default:(0,s.UT)(u)}return h.info&&(h=Object.assign({},h),delete h.info),h}))}},97797:(e,t,n)=>{n.d(t,{Fp:()=>o,Lj:()=>c,UF:()=>l,VV:()=>r,WV:()=>i,a9:()=>s});s(NaN,{name:"TODO"}),a(1),a(0),s("none");function s(e,t){return"number"==typeof e?{operation:"const",operands:[],type:"number",value:e,info:t}:{operation:"const",operands:[],type:"string",value:e,info:t}}function a(e,t){return e>=Number.MAX_VALUE/100&&(e=1/0),e<=-Number.MAX_VALUE/100&&(e=-1/0),s(e,Object.assign({unit:"%"},t))}function r(...e){return{operation:"min",operands:u(e)}}function o(...e){return{operation:"max",operands:u(e)}}function i(...e){return{operation:"mul",operands:u(e)}}function c(e,t,n,s,a){return{operation:"threshold",operands:[d(e),d(t),d(n),d(s)],info:a}}function l(e,t){return{operation:"read",operands:[],path:e,info:t,type:"number"}}function u(e){return e.map((e=>"object"==typeof e?e:s(e)))}function d(e){return"object"!=typeof e?s(e):e}},88623:(e,t,n)=>{var s=n(41015),a=n(79924),r=(n(47452),n(14613)),o=n(42652);function i(e,t){return c((0,r.VT)(e,t),(0,a.LG)(t))}function c(e,t){return e.map((e=>function(...e){const t={$c:0};for(const[s,a]of e)for(const[e,r]of Object.entries(a)){var n;t[e]=(null!=(n=t[e])?n:0)+s*r}return t}(...e.map((e=>{const n=e.terms.map((e=>t[e])),{w:a,$c:r}=function(e,t="upper"){if(0===e.length)return{w:[],$c:1,err:0};const n=e.length,a=e.map((({max:e})=>e)),r=a.reduce(((e,t)=>e*t),1);e=e.map((({min:e,max:t})=>({min:e/t,max:1})));const i=(0,s.Og)(...e.map((({min:e,max:t})=>[e,t]))).flatMap((e=>{const n=e.reduce(((e,t)=>e*t),1);let a;return"upper"===t?a=[[...e.map((e=>-e)),1,0,-n],[...e,-1,-1,n]]:"lower"===t?a=[[...e,-1,0,n],[...e.map((e=>-e)),1,-1,-n]]:(0,s.UT)(t),a})),c=[...e.map((e=>0)),0,1];try{const e=(0,o.A)(c,i);return{w:e.slice(0,n).map(((e,t)=>e*r/a[t])),$c:-r*e[n],err:r*e[n+1]}}catch(t){throw console.log("ERROR on bounds",e),console.log("Possibly numerical instability issue."),console.log(t),t}}(n,e.$k>=0?"upper":"lower"),i={$c:r};return e.terms.forEach(((e,t)=>{var n;return i[e]=a[t]+(null!=(n=i[e])?n:0)})),[e.$k,i]})))))}class l{constructor({arts:e,optTarget:t,constraints:n,topN:s},a){this.min=void 0,this.nodes=void 0,this.arts=void 0,this.topN=void 0,this.filters=[],this.interim=void 0,this.firstUncalculated=0,this.callback=void 0,this.arts=e,this.min=[-1/0,...n.map((e=>e.min))],this.nodes=[t,...n.map((e=>e.value))],this.callback=a,this.topN=s,i(this.nodes,e)}addFilter(e){const t=(0,a.t4)(this.arts,e),n=(0,a.kJ)(t);n&&this.filters.push({nodes:this.nodes,arts:t,maxConts:[],approxs:[],age:0,count:n})}setThreshold(e){e>this.min[0]&&(this.min[0]=e,this.firstUncalculated=0,this.filters.forEach((e=>delete e.calculated)))}*split(e,t){for(this.addFilter(e);this.filters.length;){console.log({thr:this.min[0]});const e=this.getApproxFilter(),{arts:n,count:a}=e;if(a<=t){if(!a)continue;this.firstUncalculated<this.filters.length&&this.calculateFilter(this.firstUncalculated++),this.reportInterim(!1),yield(0,s.xh)(n.values,(e=>({kind:"id",ids:new Set(e.map((e=>e.id)))})))}else this.splitOldFilter(e)}this.reportInterim(!0)}reportInterim(e=!1){this.interim&&(this.interim.skipped>1e6||!0===e)&&(this.callback(this.interim),this.interim=void 0)}splitOldFilter({nodes:e,arts:t,approxs:n,age:a}){const r=(0,s.xh)(t.values,(e=>{var t,s;const a=e.map((e=>({art:e,cont:n[0].conts[e.id]}))).sort((({cont:e},{cont:t})=>t-e)),r=null!=(t=null==(s=a[a.length-1])?void 0:s.cont)?t:0;let o=a.reduce(((e,{cont:t})=>e+t),-r*a.length)/3;const i=Math.max(1,a.findIndex((({cont:e})=>(o-=e-r)<=0))),c=a.splice(i).map((({art:e})=>e)),l=a.map((({art:e})=>e));return{high:{arts:l,maxConts:n.map((e=>u(l,e)))},low:{arts:c,maxConts:n.map((e=>u(c,e)))}}})),o=Object.keys(r),{filters:i}=this,c={},l={};!function u(d){if(!o.length){const r=n.map(((e,t)=>(0,s.xh)(l,(e=>e[t])))),o={base:t.base,values:Object.assign({},c)};return void i.push({nodes:e,arts:o,maxConts:r,approxs:n,age:a+1,count:d})}const p=o.pop(),{high:h,low:f}=r[p];f.arts.length&&(c[p]=f.arts,l[p]=f.maxConts,u(d*f.arts.length)),h.arts.length&&(c[p]=h.arts,l[p]=h.maxConts,u(d*h.arts.length)),o.push(p)}(1)}getApproxFilter(){return this.calculateFilter(this.filters.length-1),this.firstUncalculated>this.filters.length&&(this.firstUncalculated=this.filters.length),this.filters.pop()}calculateFilter(e){let{nodes:t,arts:n,maxConts:r,approxs:o,age:c,count:l,calculated:p}=this.filters[e];if(p)return;(c<3||c%5==2)&&(({nodes:t,arts:n}=(0,a._B)(t,this.min,n,this.topN,{},{pruneNodeRange:!0})),Object.values(n.values).every((e=>e.length))&&(o=function(e,t){return i(e,t).map((e=>({base:d(t.base,e,e.$c),conts:(0,s.Uq)(Object.values(t.values).flat(),(t=>[t.id,d(t.values,e,0)]))})))}(t,n),r=o.map((e=>(0,s.xh)(n.values,(t=>u(t,e)))))));const h=r.map(((e,t)=>Object.values(e).reduce(((e,t)=>e+t),o[t].base-this.min[t]))),f=(0,s.xh)(n.values,((e,t)=>{const n=h.map(((e,n)=>r[n][t]-e));return e.filter((({id:e})=>o.every((({conts:t},s)=>t[e]>=n[s]))))}));n={base:n.base,values:f};const m=(0,a.kJ)(n);m!==l&&(this.interim?this.interim.skipped+=l-m:this.interim={resultType:"interim",buildValues:void 0,tested:0,failed:0,skipped:l-m}),this.filters[e]={nodes:t,arts:n,maxConts:r,approxs:o,age:c,count:m,calculated:!0}}}function u(e,t){return Math.max(...e.map((({id:e})=>t.conts[e])))}function d(e,t,n){return Object.entries(e).reduce(((e,[n,s])=>{var a;return e+(null!=(a=t[n])?a:0)*s}),n)}var p=n(30597);class h{constructor({arts:e,optTarget:t,constraints:n,plotBase:s,topN:a},r){this.builds=[],this.buildValues=void 0,this.plotData=void 0,this.threshold=-1/0,this.topN=void 0,this.min=void 0,this.arts=void 0,this.nodes=void 0,this.callback=void 0,this.arts=e,this.min=n.map((e=>e.min)),this.topN=a,this.callback=r,this.nodes=n.map((e=>e.value)),this.nodes.push(t),s&&(this.plotData={},this.nodes.push(s)),this.nodes=(0,p.tL)(this.nodes,{},(e=>!1))}setThreshold(e){this.threshold>e&&(this.threshold=e)}compute(e){const{min:t}=this,n=this;let s=(0,a.t4)(this.arts,e);const r=(0,a.kJ)(s),o=this.builds.length;let i=this.nodes;({nodes:i,arts:s}=(0,a._B)(i,t,s,this.topN,{},{pruneArtRange:!0,pruneNodeRange:!0}));const c=Object.values(s.values).sort(((e,t)=>e.length-t.length)),l=(0,p.I3)(i,s.base,(e=>e.path[1]),c.length),u=Array(c.length),d={tested:0,failed:0,skipped:r-(0,a.kJ)(s)};!function e(s){if(s<0){const e=l(u);if(t.every(((t,n)=>t<=e[n]))){const s=e[t.length],{builds:a,plotData:r}=n;let o;if(s>=n.threshold&&(o={value:s,artifactIds:u.map((e=>e.id)).filter((e=>e))},a.push(o)),r){const n=e[t.length+1];(!r[n]||r[n].value<s)&&(o||(o={value:s,artifactIds:u.map((e=>e.id)).filter((e=>e))}),o.plot=n,r[n]=o)}}else d.failed+=1}else c[s].forEach((t=>{u[s]=t,e(s-1)})),0===s&&(d.tested+=c[0].length,d.tested>65536&&n.interimReport(d))}(c.length-1),this.interimReport(d,this.builds.length>o)}refresh(e){var t;const{topN:n}=this;var s;(Object.keys(null!=(t=this.plotData)?t:{}).length>=1e5&&(this.plotData=(0,a.s7)([this.plotData])),this.builds.length>=1e3||e)&&(this.builds=this.builds.sort(((e,t)=>t.value-e.value)).slice(0,n),this.buildValues=this.builds.map((e=>e.value)),this.threshold=Math.max(this.threshold,null!=(s=this.buildValues[n-1])?s:-1/0))}interimReport(e,t=!1){this.refresh(t),this.callback(Object.assign({resultType:"interim",buildValues:this.buildValues},e)),this.buildValues=void 0,e.tested=0,e.failed=0,e.skipped=0}}var f=n(60467);class m{constructor({arts:e},t){this.arts=void 0,this.stack=[],this.arts=e}setThreshold(e){}add(e,t){this.stack.push({filter:e,count:(0,a.kJ)((0,a.t4)(this.arts,e)),splittedBy:t})}*split(e,t){this.add(e,"set");for(let e=this.stack.pop();e;e=this.stack.pop()){const{filter:n,count:a,splittedBy:r}=e;if(a<=t)yield n;else switch(r){case"set":this.splitBySet(n);break;case"id":this.splitByID(n,a,t);break;default:(0,s.UT)(r)}}}splitBySet(e){const t=(0,a.t4)(this.arts,e),n=f.Ex.map((e=>({slot:e,sets:new Set(t.values[e].map((e=>e.set)))}))).filter((({sets:e})=>e.size>1));if(!n.length)return this.add(e,"id");const{sets:s,slot:r}=n.reduce(((e,t)=>e.sets.size<t.sets.size?e:t));s.forEach((t=>this.add(Object.assign({},e,{[r]:{kind:"required",sets:new Set([t])}}),"set")))}splitByID(e,t,n){const s=(0,a.t4)(this.arts,e),{slot:r,length:o}=f.Ex.map((e=>({slot:e,length:s.values[e].length}))).filter((e=>e.length>1)).reduce(((e,t)=>e.length<t.length?e:t)),i=Math.ceil(t/n),c=Math.min(i,o),l=Array(c).fill(0).map((e=>new Set));s.values[r].forEach((({id:e},t)=>l[t%c].add(e))),l.forEach((t=>this.add(Object.assign({},e,{[r]:{kind:"id",ids:t}}),"id")))}}let v,g;onmessage=async e=>{try{await async function(e){const{data:t}=e,{command:n}=t;switch(n){case"split":for(const e of v.split(t.filter,t.maxIterateSize))postMessage({command:"iterate",filter:e}),await Promise.resolve();break;case"iterate":g.compute(t.filter);break;case"threshold":return v.setThreshold(t.threshold),void g.setThreshold(t.threshold);case"finalize":{g.refresh(!0);const{builds:e,plotData:t}=g;postMessage({resultType:"finalize",builds:e,plotData:t});break}case"count":{const{exclusion:e,maxIterateSize:n}=t,s=g.arts,r=(0,a.ff)((0,a.vJ)(e,[...new Set(Object.values(s.values).flatMap((e=>e.map((e=>e.set)))))]),s);let o=0;for(const e of r)postMessage({command:"split",filter:e,maxIterateSize:n}),o+=(0,a.kJ)((0,a.t4)(s,e));postMessage({resultType:"count",count:o});break}case"setup":try{v=new l(t,(e=>postMessage(e)))}catch(e){v=new m(t,(e=>postMessage(e)))}g=new h(t,(e=>postMessage(e)));break;default:(0,s.UT)(n)}postMessage({resultType:"done"})}(e)}catch(e){postMessage({resultType:"err",message:e.message})}}},79924:(e,t,n)=>{n.d(t,{LG:()=>m,_B:()=>c,ff:()=>k,kJ:()=>x,s7:()=>w,sk:()=>v,t4:()=>b,vJ:()=>O});var s=n(40580),a=n(30597),r=n(97797),o=n(36893),i=n(41015);function c(e,t,n,s,a,r){let o=r;const i={pruneNodeRange:!0},c={pruneNodeRange:!0},h={reaffine:!0},f={pruneOrder:!0,pruneArtRange:!0,pruneNodeRange:!0};let m=0;for(;Object.values(o).some((e=>e))&&m++<20;){if(o.pruneOrder){delete o.pruneOrder;const e=u(n,s,a);n!==e&&(n=e,o=Object.assign({},o,i))}if(o.pruneArtRange){delete o.pruneArtRange;const s=d(e,n,t);n!==s&&(n=s,o=Object.assign({},o,c))}if(o.pruneNodeRange){delete o.pruneNodeRange;const t=p(e,n);e!==t&&(e=t,o=Object.assign({},o,h))}if(o.reaffine){delete o.reaffine;const{nodes:t,arts:s}=l(e,n);e===t&&n===s||(e=t,n=s,o=Object.assign({},o,f))}}return{nodes:e,arts:n}}function l(e,t,n=!1){const c=new Set,l=new Set;function u(e,t){t?c.add(e):e.operands.forEach((e=>c.has(e)&&l.add(e)))}const d=new Set;if((0,s.aD)(e,(e=>{}),(e=>{const{operation:t}=e;switch(t){case"read":d.add(e.path[1]),u(e,!0);break;case"add":u(e,e.operands.every((e=>c.has(e))));break;case"mul":{const t=e.operands.filter((e=>"const"!==e.operation));u(e,0===t.length||1===t.length&&c.has(t[0]));break}case"const":u(e,!0);break;case"res":case"threshold":case"sum_frac":case"max":case"min":u(e,!1);break;default:(0,i.UT)(t)}})),[...l].every((({operation:e})=>"read"===e||"const"===e))&&Object.keys(t.base).length===d.size)return{nodes:e,arts:t};let p=-1;function h(){for(;d.has(""+ ++p););return`${p}`}e.forEach((e=>c.has(e)&&l.add(e)));const f=[...l].filter((e=>"const"!==e.operation)),m=new Map(f.map((e=>[e,n||"read"!==e.operation||"dyn"!==e.path[0]?Object.assign({},(0,r.UF)(["dyn",`${h()}`]),{accu:"add"}):e])));function v(e){const t=(0,a.CG)([...m.keys()],{dyn:(0,i.xh)(e,(e=>(0,r.a9)(e)))},(e=>!0));return Object.fromEntries([...m.values()].map(((e,n)=>[e.path[1],t[n].value])))}const g={nodes:e=(0,s.uW)(e,(e=>{var t;return null!=(t=m.get(e))?t:e}),(e=>e)),arts:{base:v(t.base),values:(0,i.O)(o.eV,(e=>t.values[e].map((({id:e,set:t,values:n})=>({id:e,set:t,values:v(n)})))))}},b=Object.entries(v({}));for(const e of Object.values(g.arts.values))for(const{values:t}of e)for(const[e,n]of b)t[e]-=n;return g}function u(e,t,n){var s;let a=!1;const r=!(null!=(s=n.rainbow)&&s.length),c=Object.keys(e.base),l=new Set(Object.entries(n).filter((([e,t])=>t.length)).map((([e])=>e))),u=new Set(Object.entries(n).filter((([e,t])=>t.includes(2)&&!t.includes(4))).map((([e])=>e))),d=(0,i.O)(o.eV,(n=>{const s=e.values[n],o=s.filter((e=>{let n=0;return s.every((s=>{const a=c.every((t=>{var n,a;return(null!=(n=s.values[t])?n:0)>=(null!=(a=e.values[t])?a:0)})),o=c.some((t=>{var n,a;return(null!=(n=s.values[t])?n:0)>(null!=(a=e.values[t])?a:0)})),i=a&&(o||s.id>e.id),d=r&&!l.has(s.set)&&!u.has(e.set)||e.set===s.set;return i&&d&&n++,n<t}))}));return o.length!==s.length&&(a=!0),o}));return a?{base:e.base,values:d}:e}function d(e,t,n){const s=Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),a={arts:t};for(;;){const t=(0,i.O)(o.eV,(e=>f(a.arts.values[e]))),r=(0,i.O)(o.eV,(e=>h(Object.entries(t).map((t=>t[0]===e?s:t[1])).filter((e=>e)))));let c=!1;const l=(0,i.O)(o.eV,(t=>{const s=a.arts.values[t].filter((s=>{const a=h([f([s]),r[t]]),o=v(e,a);return e.every(((e,t)=>{var s;return o.get(e).max>=(null!=(s=n[t])?s:-1/0)}))}));return s.length!==a.arts.values[t].length&&(c=!0),s}));if(!c)break;a.arts={base:a.arts.base,values:l}}return a.arts}function p(e,t){const n=v(e,h([Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(t.values).map((e=>f(e)))]));return(0,s.uW)(e,(e=>{{const{min:t,max:s}=n.get(e);if(t===s)return(0,r.a9)(t)}const{operation:t}=e,s=e.operands.map((e=>n.get(e)));switch(t){case"threshold":{const[t,n,a,o]=s;if(t.min>=n.max)return e.operands[2];if(t.max<n.min)return e.operands[3];if(a.max===a.min&&o.max===o.min&&a.min===o.min&&isFinite(a.min))return(0,r.a9)(a.max);break}case"min":{const t=e.operands.filter(((e,t)=>{const n=s[t];return s.every(((e,t)=>n.min<=e.max))}));if(t.length<s.length)return(0,r.VV)(...t);break}case"max":{const t=e.operands.filter(((e,t)=>{const n=s[t];return s.every((e=>n.max>=e.min))}));if(t.length<s.length)return(0,r.Fp)(...t);break}}return e}),(e=>e))}function h(e){const t={};return e.forEach((e=>{Object.entries(e).forEach((([e,n])=>{t[e]?(t[e].min+=n.min,t[e].max+=n.max):t[e]=Object.assign({},n)}))})),t}function f(e){const t={};return e.length&&(Object.keys(e[0].values).filter((t=>e.every((e=>e.values[t])))).forEach((n=>t[n]={min:e[0].values[n],max:e[0].values[n]})),e.forEach((({values:e})=>{for(const[n,s]of Object.entries(e))t[n]?(t[n].max<s&&(t[n].max=s),t[n].min>s&&(t[n].min=s)):t[n]={min:0,max:s}}))),t}function m(e){return h([Object.fromEntries(Object.entries(e.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(e.values).map((e=>f(e)))])}function v(e,t){const n=new Map;return(0,s.aD)(e,(e=>{}),(e=>{var s;const{operation:r}=e,o=e.operands.map((e=>n.get(e)));let c;switch(r){case"read":if("dyn"!==e.path[0])throw new Error(`Found non-dyn path ${e.path} while computing range`);c=null!=(s=t[e.path[1]])?s:{min:0,max:0};break;case"const":c=g([e.value]);break;case"add":case"min":case"max":c={min:a.aj[r](o.map((e=>e.min))),max:a.aj[r](o.map((e=>e.max)))};break;case"res":c={min:a.aj[r]([o[0].max]),max:a.aj[r]([o[0].min])};break;case"mul":c=o.reduce(((e,t)=>g([e.min*t.min,e.min*t.max,e.max*t.min,e.max*t.max])));break;case"threshold":c=o[0].min>=o[1].max?o[2]:o[0].max<o[1].min?o[3]:g([],[o[2],o[3]]);break;case"sum_frac":{const[e,t]=o,n={min:e.min+t.min,max:e.max+t.max};c=n.min<=0&&n.max>=0?e.min<=0&&e.max>=0?{min:NaN,max:NaN}:{min:-1/0,max:1/0}:g([e.min/n.min,e.min/n.max,e.max/n.min,e.max/n.max]);break}default:(0,i.UT)(r)}n.set(e,c)})),n}function g(e,t=[]){const n=Math.max(...e,...t.map((e=>e.max)));return{min:Math.min(...e,...t.map((e=>e.min))),max:n}}function b(e,t){return{base:e.base,values:(0,i.O)(o.eV,(n=>{const s=t[n];switch(s.kind){case"id":return e.values[n].filter((e=>s.ids.has(e.id)));case"exclude":return e.values[n].filter((e=>!s.sets.has(e.set)));case"required":return e.values[n].filter((e=>s.sets.has(e.set)))}}))}}function w(e){let t=.01,n=new Set(e.flatMap((e=>Object.values(e).map((e=>Math.round(e.plot/t))))));for(;n.size>1500;)t*=2,n=new Set([...n].map((e=>Math.round(e/2))));const s={};for(const n of e)for(const e of Object.values(n)){const n=Math.round(e.plot/t)*t;(!s[n]||s[n].value<e.value)&&(s[n]=e)}return s}function x(e){return o.eV.reduce(((t,n)=>t*e.values[n].length),1)}function*k(e,t){const n=(0,i.xh)(t.values,(e=>new Set(e.map((e=>e.set)))));e:for(const t of e){for(const[e,s]of Object.entries(t)){const t=n[e];switch(s.kind){case"required":if([...s.sets].every((e=>!t.has(e))))continue e;break;case"exclude":if([...t].every((e=>s.sets.has(e))))continue e}}yield t}}function y(e){return new Set(null!=e&&e.includes(2)?e.includes(4)?[0,1]:[0,1,4,5]:null!=e&&e.includes(4)?[0,1,2,3]:[0,1,2,3,4,5])}function*O(e,t){const n=[...new Set(t)],s=y(e.rainbow);let a=[];function r(e,t){if(!(0,i.w6)(t+1,4).some((t=>5!==e[t])))return(e=[...e])[t]=5,e.reduce(((e,t)=>6*e+t),0)}!function e(t,n,r){if(5!==t.length){for(const s of n)e([...t,s],n,r.filter((e=>e!==s)));e([...t,t.length],new Set([...n,t.length]),[...r,t.length])}else s.has(r.length)&&a.push(t)}([0],new Set([0]),[0]);for(let e=4;e>=0;e--){const t=new Map;for(const n of a){var c;const s=r(n,e);void 0!==s&&t.set(s,(null!=(c=t.get(s))?c:new Set(n.slice(0,e)).size+1)-1)}for(const[n,s]of t.entries())if(0===s){const t=[...a.find((t=>r(t,e)===n))];t[e]=5,a=a.filter((t=>r(t,e)!==n)),a.push(t)}}const l={kind:"exclude",sets:new Set},u=(0,i.O)(o.eV,(e=>l)),d=Object.assign({},(0,i.xh)(e,(e=>0)),(0,i.O)(n,(e=>0))),p=(0,i.xh)(e,y);function*h(e){const t=new Set;let s=[],a=[];for(const t of e)s.push([]),5===t?a.push(s.length-1):s[t].push(s.length-1);s=s.filter((e=>e.length)).sort(((e,t)=>t.length-e.length));let r=a.length;function*c(e){const t=a.length-e,s=[],r=[],l=[];let h=0;for(const e of n){const n=p[e],a=d[e];n&&((0,i.w6)(1,t).every((e=>!n.has(a+e)))?l.push(e):n.has(a)?(0,i.w6)(0,t).some((e=>!n.has(a+e)))&&s.push(e):(h+=[...n].find((e=>e>a))-a,r.push(e)))}if(!(h>t))if(e!==a.length)if(h!==t){for(const t of[...s,...r])d[t]++,u[o.eV[a[e]]]={kind:"required",sets:new Set([t])},yield*c(e+1),d[t]--;u[o.eV[a[e]]]={kind:"exclude",sets:new Set([...r,...l,...s])},yield*c(e+1)}else for(const t of r)d[t]++,u[o.eV[a[e]]]={kind:"required",sets:new Set([t])},yield*c(e+1),d[t]--;else yield Object.assign({},u)}yield*function*e(a){if(a===s.length)return yield*c(0);for(const c of n){if(t.has(c))continue;const n=s[a].length,h=p[c];let f=0;var l;if(h&&!h.has(n))if(f=(null!=(l=(0,i.w6)(n+1,5).find((e=>h.has(e))))?l:6)-n,f>r)continue;t.add(c),d[c]=s[a].length,s[a].forEach((e=>u[o.eV[e]]={kind:"required",sets:new Set([c])})),r-=f,yield*e(a+1),r+=f,d[c]=0,t.delete(c)}}(0)}for(const e of a)yield*h(e)}},47452:(e,t,n)=>{n(60467)},36893:(e,t,n)=>{n.d(t,{eV:()=>a});var s=n(60467);const a=["flower","plume","sands","goblet","circlet"],r=(s.Kn,["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"]);s.Kn,s.Kn,s.j4,s.X7,s.ie,s.oK,s.Xt},41015:(e,t,n)=>{n.d(t,{Hm:()=>s,O:()=>a,Og:()=>u,UT:()=>l,Uq:()=>r,w6:()=>c,xh:()=>o});function s(e,t){if(e&&t)return!Array.isArray(t)&&console.error(t),t.reduce(((e,t)=>null==e?void 0:e[t]),e)}function a(e,t){return Object.fromEntries(e.map(((e,n)=>[e,t(e,n)])))}function r(e,t){return Object.fromEntries(e.map(((e,n)=>t(e,n))))}function o(e,t){return Object.fromEntries(Object.entries(e).map((([e,n],s)=>[e,t(n,e,s)])))}const i=function*(e,t){for(let n=e;n<=t;n++)yield n};function c(e,t){return[...i(e,t)]}function l(e){throw new Error(`Should not reach this with value ${e}`)}function u(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,[t]].flat()))))),[[]])}},60467:(e,t,n)=>{n.d(t,{Ex:()=>a,oK:()=>r.oK,Xt:()=>r.Xt,X7:()=>r.X7,ie:()=>r.ie,j4:()=>r.j4,Kn:()=>s.Kn});var s=n(10533);const a=["flower","plume","sands","goblet","circlet"];var r=n(7664)}},s={};function a(e){var t=s[e];if(void 0!==t)return t.exports;var r=s[e]={exports:{}};return n[e](r,r.exports,a),r.exports}a.m=n,a.x=()=>{var e=a.O(void 0,[592],(()=>a(88623)));return e=a.O(e)},e=[],a.O=(t,n,s,r)=>{if(!n){var o=1/0;for(u=0;u<e.length;u++){for(var[n,s,r]=e[u],i=!0,c=0;c<n.length;c++)(!1&r||o>=r)&&Object.keys(a.O).every((e=>a.O[e](n[c])))?n.splice(c--,1):(i=!1,r<o&&(o=r));if(i){e.splice(u--,1);var l=s();void 0!==l&&(t=l)}}return t}r=r||0;for(var u=e.length;u>0&&e[u-1][2]>r;u--)e[u]=e[u-1];e[u]=[n,s,r]},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.f={},a.e=e=>Promise.all(Object.keys(a.f).reduce(((t,n)=>(a.f[n](e,t),t)),[])),a.u=e=>"common.5736e915304df49d.js",a.miniCssF=e=>{},a.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.j=623,(()=>{var e;a.g.importScripts&&(e=a.g.location+"");var t=a.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");n.length&&(e=n[n.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),a.p=e})(),(()=>{var e={623:1};a.f.i=(t,n)=>{e[t]||importScripts(a.p+a.u(t))};var t=self.webpackChunk=self.webpackChunk||[],n=t.push.bind(t);t.push=t=>{var[s,r,o]=t;for(var i in r)a.o(r,i)&&(a.m[i]=r[i]);for(o&&o(a);s.length;)e[s.pop()]=1;n(t)}})(),t=a.x,a.x=()=>a.e(592).then(t);a.x()})();