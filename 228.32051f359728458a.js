(()=>{"use strict";var e,t,n={40580:(e,t,n)=>{n.d(t,{Gd:()=>o,aD:()=>r,uW:()=>a});var s=n(97797);function r(e,t,n){const s=new Set,r=new Set;e.forEach((function e(a){r.has(a)||(s.has(a)?console.error("Found cyclical dependency during formula traversal"):(s.add(a),t(a),a.operands.forEach(e),n(a),s.delete(a),r.add(a)))}))}function a(e,t,n){const r=new Set,a=new Map,o=new Map;function c(e){let l=a.get(e);if(l)return l;l=t(e);let u=o.get(l);return u||(r.has(l)?(console.error("Found cyclical dependency during formula mapping"),(0,s.a9)(NaN)):(r.add(l),u=n(function(e){const t=e.operands.map(c);return i(t,e.operands)?e:Object.assign({},e,{operands:t})}(l),e),r.delete(l),a.set(e,u),o.set(l,u),u))}const l=e.map(c);return i(l,e)?e:l}function o(e,t,n){const s=new Map;function r(e,t){let a=s.get(t);a||s.set(t,a=[new Set,new Map]);const[o,i]=a,c=i.get(e);if(c)return c;if(o.has(e))throw new Error("Found cyclical dependency during formula mapping");o.add(e);const l=n(e,t,r);return i.set(e,l),o.delete(e),l}return e.map((e=>r(e,t)))}function i(e,t){return void 0===e?void 0===t:void 0!==t&&(e.length===t.length&&e.every(((e,n)=>e===t[n])))}},30597:(e,t,n)=>{n.d(t,{CG:()=>f,I3:()=>u,aj:()=>i,tL:()=>l});var s=n(41015),r=n(40580),a=n(97797);const o={min:e=>Math.min(...e),max:e=>Math.max(...e),add:e=>e.reduce(((e,t)=>e+t),0),mul:e=>e.reduce(((e,t)=>e*t),1)},i=Object.assign({},o,{res:([e])=>e<0?1-e/2:e>=.75?1/(4*e+1):1-e,sum_frac:e=>e[0]/e.reduce(((e,t)=>e+t)),threshold:([e,t,n,s])=>e>=t?n:s}),c=new Set(Object.keys(o));function l(e,t,n=(e=>!1)){let s=f(e,t,n);return s=p(s),d(s)}function u(e,t,n,a){let o='\n"use strict";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0',i=1;const c=new Map;return(0,r.aD)(e,(e=>{}),(e=>{const{operation:r,operands:l}=e,u="x"+i++,p=l.map((e=>c.get(e)));switch(c.set(e,u),r){case"read":{const s=n(e);let r=new Array(a).fill(null).map(((e,t)=>`(b[${t}].values["${s}"] ?? 0)`));t[s]&&0!==t[s]&&(r=[t[s].toString(),...r]),o+=`,${u}=${r.join("+")}`;break}case"const":c.set(e,`(${e.value})`);break;case"add":case"mul":o+=`,${u}=${p.join("add"===r?"+":"*")}`;break;case"min":case"max":o+=`,${u}=Math.${r}(${p})`;break;case"threshold":{const[e,t,n,s]=p;o+=`,${u}=(${e}>=${t})?${n}:${s}`;break}case"res":o+=`,${u}=res(${p[0]})`;break;case"sum_frac":o+=`,${u}=${p[0]}/(${p[0]}+${p[1]})`;break;default:(0,s.UT)(r)}})),o+=`;\nreturn [${e.map((e=>c.get(e)))}]`,new Function("b",o)}function p(e){return(0,r.uW)(e,(e=>e),(e=>{let t=e;if(c.has(e.operation)){const n=e,{operation:s}=n;let r=!1;const a=n.operands.flatMap((e=>e.operation===s?(r=!0,e.operands):[e]));t=r?Object.assign({},n,{operands:a}):n}return t}))}function d(e){function t(e){const t=new Map;for(const s of e){var n;t.set(s,(null!=(n=t.get(s))?n:0)+1)}return t}const n={common:{counts:new Map,formulas:new Set,operation:"add"}};for(;;){let a;const i={operation:n.common.operation,operands:(s=n.common.counts,[...s].flatMap((([e,t])=>Array(t).fill(e))))},l=new Map;for(const e of Object.keys(o))l.set(e,[]);if(e=(0,r.uW)(e,(e=>{if(n.common.formulas.has(e)){const t=e,s=new Map(n.common.counts),r=t.operands.filter((e=>{const t=s.get(e);return!t||(s.set(e,t-1),!1)}));return r.length?(r.push(i),Object.assign({},t,{operands:r})):i}return e}),(e=>{if(!c.has(e.operation))return e;const n=e;if(a){if(a.operation===n.operation){const e=t(n.operands),r=new Map,o=a.counts;let i=0;for(const[t,n]of e.entries()){var s;const e=Math.min(n,null!=(s=o.get(t))?s:0);e?(r.set(t,e),i+=e):r.delete(t)}i>1&&(a.counts=r,a.formulas.add(n))}}else{const e=l.get(n.operation),s=t(n.operands);for(const[t,o]of e){let e=0;const i=new Map;for(const[t,n]of o.entries()){var r;const a=Math.min(n,null!=(r=s.get(t))?r:0);a&&(i.set(t,a),e+=a)}if(e>1){a={counts:i,formulas:new Set([n,t]),operation:n.operation},l.clear();break}}a||e.push([n,s])}return n})),!a)break;n.common=a}var s;return e}function f(e,t,n=(e=>!1)){const o={data:[],processed:new Map},c=new Map([[o,new Map]]),l={data:[t],processed:new Map};return c.set(l,new Map),c.get(o).set(t,l),(0,r.Gd)(e,l,((e,t,r)=>{const{operation:l}=e,u=(e,t)=>r(e,t),p=(e,t)=>r(e,t);let d;switch(l){case"const":d=e;break;case"add":case"mul":case"max":case"min":{var f;const n=i[l],s=[],r=e.operands.filter((e=>{const n=u(e,t);return"const"!==n.operation||(s.push(n.value),!1)})).map((e=>u(e,t))),o=n(s);if(isFinite(o)){if("mul"===l&&0===o){d=(0,a.a9)(o);break}}else if("mul"!==l&&("max"!==l||o>0)&&("min"!==l||o<0)){d=(0,a.a9)(o);break}o!==n([])&&r.push((0,a.a9)(o)),d=r.length<=1?null!=(f=r[0])?f:(0,a.a9)(n([])):{operation:l,operands:r};break}case"res":case"sum_frac":{const n=e.operands.map((e=>u(e,t))),s=i[l];d=n.every((e=>"const"===e.operation))?(0,a.a9)(s(n.map((e=>e.value)))):Object.assign({},e,{operands:n});break}case"lookup":{const n=p(e.operands[0],t);if("const"===n.operation){var h;const s=null!=(h=e.table[n.value])?h:e.operands[1];if(s){d=r(s,t);break}}throw new Error(`Unsupported ${l} node while folding`)}case"prio":{const n=e.operands.find((e=>{const n=p(e,t);if("const"!==n.operation)throw new Error(`Unsupported ${l} node while folding`);return void 0!==n.value}));d=n?p(n,t):(0,a.a9)(void 0);break}case"small":{var m;let n;for(const s of e.operands){var g;const e=p(s,t);if("const"!==e.operation)throw new Error(`Unsupported ${l} node while folding`);(void 0===(null==(g=n)?void 0:g.value)||void 0!==e.value&&e.value<n.value)&&(n=e)}d=null!=(m=n)?m:(0,a.a9)(void 0);break}case"match":{const[n,s,a,o]=e.operands.map((e=>r(e,t)));if("const"!==n.operation||"const"!==s.operation)throw new Error(`Unsupported ${l} node while folding`);d=n.value===s.value?a:o;break}case"threshold":{const[n,s,a,o]=e.operands.map((e=>r(e,t)));d="const"===a.operation&&"const"===o.operation&&a.value===o.value?a:"const"===n.operation&&"const"===s.operation?n.value>=s.value?a:o:Object.assign({},e,{operands:[n,s,a,o]});break}case"subscript":{const n=u(e.operands[0],t);if("const"!==n.operation)throw new Error("Found non-constant subscript node while folding");d=(0,a.a9)(e.list[n.value]);break}case"read":{const o=t.data.map((t=>(0,s.Hm)(t,e.path))).filter((e=>e));if(0===o.length)if(n(e)){const{accu:t}=e;d=void 0===t||"small"===t?"string"===e.type?(0,a.a9)(void 0):(0,a.a9)(NaN):(0,a.a9)(i[t]([]))}else d=e;else d=void 0===e.accu||1===o.length?r(o[o.length-1],t):r({operation:e.accu,operands:o},t);break}case"data":{e.reset&&(t=o);const n=c.get(t);let s=n.get(e.data);s||(s={data:[...t.data,e.data],processed:new Map},c.set(s,new Map),n.set(e.data,s)),d=r(e.operands[0],s);break}default:(0,s.UT)(l)}return d.info&&(d=Object.assign({},d),delete d.info),d}))}},97797:(e,t,n)=>{n.d(t,{Fp:()=>o,Lj:()=>c,UF:()=>l,VV:()=>a,WV:()=>i,a9:()=>s});s(NaN,{name:"TODO"}),r(1),r(0),s("none");function s(e,t){return"number"==typeof e?{operation:"const",operands:[],type:"number",value:e,info:t}:{operation:"const",operands:[],type:"string",value:e,info:t}}function r(e,t){return e>=Number.MAX_VALUE/100&&(e=1/0),e<=-Number.MAX_VALUE/100&&(e=-1/0),s(e,Object.assign({unit:"%"},t))}function a(...e){return{operation:"min",operands:u(e)}}function o(...e){return{operation:"max",operands:u(e)}}function i(...e){return{operation:"mul",operands:u(e)}}function c(e,t,n,s,r){return{operation:"threshold",operands:[p(e),p(t),p(n),p(s)],info:r}}function l(e,t){return{operation:"read",operands:[],path:e,info:t,type:"number"}}function u(e){return e.map((e=>"object"==typeof e?e:s(e)))}function p(e){return"object"!=typeof e?s(e):e}},28228:(e,t,n)=>{var s=n(41015),r=n(79924),a=n(40580),o=n(30597),i=n(97797);function c(e){return{type:"lin",lin:{$c:e},min:e,max:e}}function l(...e){const t=e.filter((e=>"number"==typeof e)).reduce(((e,t)=>e+t),0),n=e.filter((e=>"number"!=typeof e));return{type:"sum",terms:n,$c:t,min:n.reduce(((e,{min:t})=>e+t),t),max:n.reduce(((e,{max:t})=>e+t),t)}}function u(...e){const t=e.filter((e=>"number"==typeof e)).reduce(((e,t)=>e*t),1),n=e.filter((e=>"number"!=typeof e)),s=n.reduce((({min:e,max:t},{min:n,max:s})=>({min:Math.min(e*n,e*s,t*n,t*s),max:Math.max(e*n,e*s,t*n,t*s)})),{min:t,max:t});return Object.assign({type:"prod",terms:n,$k:t},s)}function p(e,t,n,s){return l(n-e*t,u(e,s))}function d(e,t,n,s,r,a){return Math.abs(e-n)<1e-10?c(a?Math.max(t,s):Math.min(t,s)):p((s-t)/(n-e),e,t,r)}function f(e,t){const n=new Map;(0,a.aD)(e,(e=>{const{operation:t}=e;switch("mul"===t&&n.set(e,{min:NaN,max:NaN}),t){case"mul":case"min":case"max":case"threshold":case"res":case"sum_frac":e.operands.forEach((e=>n.set(e,{min:NaN,max:NaN})))}}),(e=>e));const f=(0,r.LG)(t),g=(0,r.sk)([...n.keys()],f);for(const[e,t]of g.entries())n.set(e,t);const v="u",b="l",w="e";return(0,a.Gd)(e,v,((e,t,r)=>{const{operation:a}=e,f=(e,n=t)=>r(e,n),h=t===v?b:v;switch(a){case"const":return c(e.value);case"read":return g=e.path[1],x=n.get(e),Object.assign({type:"lin",lin:{[g]:1,$c:0}},x);case"add":return l(...e.operands.map((e=>f(e))));case"mul":{if(t===w)return u(...e.operands.map((e=>f(e))));const{min:s,max:r}=n.get(e);if(s===r)return c(s);const i=s*r<0||e.operands.some((e=>{const{min:t,max:s}=n.get(e);return t*s<0}));if(i)return f(e,w);const l=0===s?r:s,p=(0,o.aj[a])(e.operands.filter((e=>"const"===e.operation)).map((e=>e.value))),d=e.operands.filter((e=>"const"!==e.operation)).map((e=>{const{min:s,max:r}=n.get(e),o=l*(0===s?r:s)>0?t:h,i=f(e,o);if(o===b&&r>0&&i.min<-s||o===v&&s<0&&i.max>-r)throw new m("Unallowed large crossing post approximation",a);return i}));return u(p,...d)}case"min":case"max":{if(t===w)throw new m("Cannot be exactly represented",a);const s=o.aj[a],r=e.operands.filter((e=>"const"!==e.operation)),[i]=r;if(1!==r.length)throw new m("Multivariate",a);const c=f(i),l=s(e.operands.filter((e=>"const"===e.operation)).map((e=>e.value)));if("max"===a&&t===b||"min"===a&&t===v)return c;const{min:u,max:p}=n.get(i);return d(u,s([u,l]),p,s([p,l]),c,t===v)}case"res":{if(t===w)throw new m("Cannot be exactly represented",a);if(t===b)throw new m("Unsupported direction",a);const s=o.aj[a],[r]=e.operands,{min:i,max:c}=n.get(r),p=f(r,h);return i<0&&c<1.75?l(1,u(-.5,p)):d(i,s([i]),c,s([c]),p,t===v)}case"sum_frac":{if(t===w)throw new m("Cannot be exactly represented",a);if(t===b)throw new m("Unsupported direction",a);const[s,r]=e.operands;if("const"!==r.operation)throw new m("Non-constant node",a);const o=f(s),i=r.value,{min:c,max:l}=n.get(s);if(c<=-i)throw new m("Unallowed negative argument",a);const u=Math.sqrt((c+i)*(l+i));return p(i/(u+i)/(u+i),u,u/(u+i),o)}case"threshold":{if(t===w)throw new m("Cannot be exactly represented",a);const[s,r,o,l]=e.operands;if("const"!==r.operation)throw new m("Non-constant node",a);const{min:u,max:d}=n.get(s);if(u>=r.value)return f(o);if(d<r.value)return f(l);if("const"!==l.operation)throw new m("Non-constant node",a);if("const"!==o.operation){if(0!==l.value)throw new m("Unsupported pattern",a);const e=(0,i.Lj)(s,r,1,l),t=(0,i.WV)(e,o),{min:c,max:u}=n.get(o);return n.set(e,{min:0,max:1}),n.set(t,{min:Math.min(c,0),max:Math.max(u,0)}),f(t)}const h=r.value,g=o.value,x=l.value,y=g>x==(t===v),k=f(s,y?v:b);if(y){return p((g-x)/(h-u),h,g,k)}return c(x)}default:(0,s.UT)(a)}var g,x})).map((e=>function(e){function t(e){switch(e.type){case"lin":return Object.entries(e.lin).filter((([e,t])=>0!==t)).map((([e,t])=>"$c"===e?h(t):function(e,t){return{$k:t,terms:[e]}}(e,t)));case"sum":return function(...e){return e.flat()}(...e.terms.map((e=>t(e))),[h(e.$c)]);case"prod":return function(...e){return(0,s.Og)(...e).map((e=>e.reduce(((e,t)=>(e.$k*=t.$k,e.terms.push(...t.terms),e)),{$k:1,terms:[]})))}(...e.terms.map((e=>t(e))),[h(e.$k)])}}return function(e){e.forEach((e=>e.terms.sort())),e.sort((({terms:e},{terms:t})=>{if(e.length!==t.length)return e.length-t.length;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e[n]<t[n]?-1:1;return 0}));for(let t=e.length-2;t>=0;t--){if(0===e[t].$k){e.splice(t,1);continue}const n=e[t].terms,s=e[t+1].terms;n.length===s.length&&(n.every(((e,t)=>e===s[t]))&&(e[t].$k=e[t].$k+e[t+1].$k,e.splice(t+1,1)))}return e}(t(e))}(e)))}function h(e){return{$k:e,terms:[]}}class m extends Error{constructor(e,t){super(`Found ${e} in ${t} node when generating polynomial upper bound`)}}const g=1e-8;function v(e,t){const n=t.length+1,s=t[0].length,r=Array(n).fill(0).map((e=>Array(s).fill(0)));t.forEach(((e,t)=>e.forEach(((e,n)=>r[t][n]=e)))),e.forEach(((e,t)=>r[n-1][t]=e));const a=[];for(;r.some(((e,t)=>t<n-1&&e[s-1]<-1e-8));){const e=x(r);a.push(e),b(r,e)}for(;r[n-1].some(((e,t)=>t<s-1&&e<-1e-8));){const e=w(r);a.push(e),b(r,e)}const o=e.map(((e,t)=>function(e,t,n){let s=1;t.forEach((({i:e,j:t})=>{1===s&&t===n?(n=e,s=0):0===s&&e===n&&(n=t,s=1)}));const r=e[0].length;return 0===s?e[n][r-1]:0}(r,a,t)));if(!function(e,t){const n=t.length;return e.every((e=>t.reduce(((t,n,s)=>t+n*e[s]),0)<=e[n]+g))}(t,o))throw Error("COMPUTED SOLUTION IS NOT FEASIBLE");return o}function b(e,{i:t,j:n}){const s=e[t][n];for(let r=0;r<e.length;r++)if(r!==t)for(let a=0;a<e[0].length;a++)a!==n&&(e[r][a]-=e[t][a]*e[r][n]/s);for(let r=0;r<e.length;r++)r!==t&&(e[r][n]=-e[r][n]/s);for(let r=0;r<e[0].length;r++)r!==n&&(e[t][r]=e[t][r]/s);e[t][n]=1/s}function w(e){const t=e.length,n=e[0].length;let s={i:-1,j:-1,cmp:1/0};for(let r=0;r<n-1;r++)if(!(e[t-1][r]>=-1e-8)){for(let a=0;a<t-1;a++)if(e[a][r]>g){const t=e[a][n-1]/e[a][r];t<s.cmp&&(s={i:a,j:r,cmp:t})}if(s.i<0)throw Error("UNBOUNDED FEASIBLE")}if(s.i<0)throw Error("NO PIVOTS (done)");return{i:s.i,j:s.j}}function x(e){const t=e.length,n=e[0].length;let s={i:-1,j:-1,cmp:1/0};for(let r=0;r<t-1;r++)if(!(e[r][n-1]>=-1e-8)){for(let t=0;t<n-1;t++)if(e[r][t]<-1e-8){const a=e[r][n-1]/e[r][t];a<s.cmp&&(s={i:r,j:t,cmp:a})}if(s.i<0)throw Error("INFEASIBLE");return{i:s.i,j:s.j}}throw Error("NO PIVOTS (done)")}function y(e,t){const n=f(e,t),a=(0,r.LG)(t);return n.map((e=>function(...e){const t={$c:0};for(const[s,r]of e)for(const[e,a]of Object.entries(r)){var n;t[e]=(null!=(n=t[e])?n:0)+s*a}return t}(...e.map((e=>{const t=e.terms.map((e=>a[e])),{w:n,$c:r}=function(e,t="upper"){if(0===e.length)return{w:[],$c:1,err:0};const n=e.length,r=e.map((({min:e,max:t})=>Math.max(-e,t))),a=r.reduce(((e,t)=>e*t),1);e=e.map((({min:e,max:t},n)=>({min:e/r[n],max:t/r[n]})));const o=(0,s.Og)(...e.map((({min:e,max:t})=>[e,t]))).flatMap((e=>{const r=e.reduce(((e,t)=>e*t),1),a=e.reduce(((e,t)=>e+t),0);switch(t){case"upper":return[[...e,-1,0,a-r-n],[...e.map((e=>-e)),1,-1,n+r-a]];case"lower":return[[...e.map((e=>-e)),-1,0,r-a-n],[...e,1,-1,n+a-r]];default:(0,s.UT)(t)}})),i=[...e.map((e=>0)),0,1];try{const e=v(i,o);switch(t){case"upper":return{w:e.slice(0,n).map(((e,t)=>(1-e)*a/r[t])),$c:a*(e[n]-n),err:a*e[n+1]};case"lower":return{w:e.slice(0,n).map(((e,t)=>(1-e)*a/r[t])),$c:a*(n-e[n]),err:a*e[n+1]};default:(0,s.UT)(t)}}catch(t){throw console.log("ERROR on bounds",e),console.log("Possibly numerical instability issue."),console.log(t),t}}(t,e.$k>=0?"upper":"lower"),o={$c:r};return e.terms.forEach(((e,t)=>{var s;return o[e]=n[t]+(null!=(s=o[e])?s:0)})),[e.$k,o]})))))}class k{constructor({arts:e,optTarget:t,constraints:n,topN:s},r){this.min=void 0,this.nodes=void 0,this.arts=void 0,this.topN=void 0,this.filters=[],this.interim=void 0,this.firstUncalculated=0,this.callback=void 0,this.arts=e,this.min=[-1/0,...n.map((e=>e.min))],this.nodes=[t,...n.map((e=>e.value))],this.callback=r,this.topN=s,y(this.nodes,e)}addFilter(e){const t=(0,r.t4)(this.arts,e),n=(0,r.kJ)(t);n&&this.filters.push({nodes:this.nodes,arts:t,maxConts:[],approxs:[],age:0,count:n})}setThreshold(e){e>this.min[0]&&(this.min[0]=e,this.firstUncalculated=0,this.filters.forEach((e=>delete e.calculated)))}*split(e,t){for(this.addFilter(e);this.filters.length;){const e=this.getApproxFilter(),{arts:n,count:r}=e;if(r<=t){if(!r)continue;this.firstUncalculated<this.filters.length&&this.calculateFilter(this.firstUncalculated++),this.reportInterim(!1),yield(0,s.xh)(n.values,(e=>({kind:"id",ids:new Set(e.map((e=>e.id)))})))}else this.splitOldFilter(e)}this.reportInterim(!0)}reportInterim(e=!1){this.interim&&(this.interim.skipped>1e6||!0===e)&&(this.callback(this.interim),this.interim=void 0)}splitOldFilter({nodes:e,arts:t,approxs:n,age:r}){const a=(0,s.xh)(t.values,(e=>{var t,s;const r=e.map((e=>({art:e,cont:n[0].conts[e.id]}))).sort((({cont:e},{cont:t})=>t-e)),a=null!=(t=null==(s=r[r.length-1])?void 0:s.cont)?t:0;let o=r.reduce(((e,{cont:t})=>e+t),-a*r.length)/3;const i=Math.max(1,r.findIndex((({cont:e})=>(o-=e-a)<=0))),c=r.splice(i).map((({art:e})=>e)),l=r.map((({art:e})=>e));return{high:{arts:l,maxConts:n.map((e=>O(l,e)))},low:{arts:c,maxConts:n.map((e=>O(c,e)))}}})),o=Object.keys(a),{filters:i}=this,c={},l={};!function u(p){if(!o.length){const a=n.map(((e,t)=>(0,s.xh)(l,(e=>e[t])))),o={base:t.base,values:Object.assign({},c)};return void i.push({nodes:e,arts:o,maxConts:a,approxs:n,age:r+1,count:p})}const d=o.pop(),{high:f,low:h}=a[d];h.arts.length&&(c[d]=h.arts,l[d]=h.maxConts,u(p*h.arts.length)),f.arts.length&&(c[d]=f.arts,l[d]=f.maxConts,u(p*f.arts.length)),o.push(d)}(1)}getApproxFilter(){return this.calculateFilter(this.filters.length-1),this.firstUncalculated>this.filters.length&&(this.firstUncalculated=this.filters.length),this.filters.pop()}calculateFilter(e){let{nodes:t,arts:n,maxConts:a,approxs:o}=this.filters[e];const{age:i,count:c,calculated:l}=this.filters[e];if(l)return;(i<3||i%5==2)&&(({nodes:t,arts:n}=(0,r._B)(t,this.min,n,this.topN,{},{pruneNodeRange:!0})),Object.values(n.values).every((e=>e.length))&&(o=function(e,t){return y(e,t).map((e=>({base:j(t.base,e,e.$c),conts:(0,s.Uq)(Object.values(t.values).flat(),(t=>[t.id,j(t.values,e,0)]))})))}(t,n),a=o.map((e=>(0,s.xh)(n.values,(t=>O(t,e)))))));const u=a.map(((e,t)=>Object.values(e).reduce(((e,t)=>e+t),o[t].base-this.min[t]))),p=(0,s.xh)(n.values,((e,t)=>{const n=u.map(((e,n)=>a[n][t]-e));return e.filter((({id:e})=>o.every((({conts:t},s)=>t[e]>=n[s]))))}));n={base:n.base,values:p};const d=(0,r.kJ)(n);d!==c&&(this.interim?this.interim.skipped+=c-d:this.interim={resultType:"interim",buildValues:void 0,tested:0,failed:0,skipped:c-d}),this.filters[e]={nodes:t,arts:n,maxConts:a,approxs:o,age:i,count:d,calculated:!0}}}function O(e,t){return Math.max(...e.map((({id:e})=>t.conts[e])))}function j(e,t,n){return Object.entries(e).reduce(((e,[n,s])=>{var r;return e+(null!=(r=t[n])?r:0)*s}),n)}class M{constructor({arts:e,optTarget:t,constraints:n,plotBase:s,topN:r},a){this.builds=[],this.buildValues=void 0,this.plotData=void 0,this.threshold=-1/0,this.topN=void 0,this.min=void 0,this.arts=void 0,this.nodes=void 0,this.callback=void 0,this.arts=e,this.min=n.map((e=>e.min)),this.topN=r,this.callback=a,this.nodes=n.map((e=>e.value)),this.nodes.push(t),s&&(this.plotData={},this.nodes.push(s)),this.nodes=(0,o.tL)(this.nodes,{},(e=>!1))}setThreshold(e){this.threshold>e&&(this.threshold=e)}compute(e){const{min:t}=this;let n=(0,r.t4)(this.arts,e);const s=(0,r.kJ)(n),a=this.builds.length;let i=this.nodes;({nodes:i,arts:n}=(0,r._B)(i,t,n,this.topN,{},{pruneArtRange:!0,pruneNodeRange:!0}));const c=Object.values(n.values).sort(((e,t)=>e.length-t.length)),l=(0,o.I3)(i,n.base,(e=>e.path[1]),c.length),u=Array(c.length),p={tested:0,failed:0,skipped:s-(0,r.kJ)(n)},d=e=>{if(e<0){const e=l(u);if(t.every(((t,n)=>t<=e[n]))){const n=e[t.length],{builds:s,plotData:r}=this;let a;if(n>=this.threshold&&(a={value:n,artifactIds:u.map((e=>e.id)).filter((e=>e))},s.push(a)),r){const s=e[t.length+1];(!r[s]||r[s].value<n)&&(a||(a={value:n,artifactIds:u.map((e=>e.id)).filter((e=>e))}),a.plot=s,r[s]=a)}}else p.failed+=1}else c[e].forEach((t=>{u[e]=t,d(e-1)})),0===e&&(p.tested+=c[0].length,p.tested>65536&&this.interimReport(p))};d(c.length-1),this.interimReport(p,this.builds.length>a)}refresh(e){var t;const{topN:n}=this;var s;(Object.keys(null!=(t=this.plotData)?t:{}).length>=1e5&&(this.plotData=(0,r.s7)([this.plotData])),this.builds.length>=1e3||e)&&(this.builds=this.builds.sort(((e,t)=>t.value-e.value)).slice(0,n),this.buildValues=this.builds.map((e=>e.value)),this.threshold=Math.max(this.threshold,null!=(s=this.buildValues[n-1])?s:-1/0))}interimReport(e,t=!1){this.refresh(t),this.callback(Object.assign({resultType:"interim",buildValues:this.buildValues},e)),this.buildValues=void 0,e.tested=0,e.failed=0,e.skipped=0}}var $=n(60467);class E{constructor({arts:e},t){this.arts=void 0,this.stack=[],this.arts=e}setThreshold(e){}add(e,t){this.stack.push({filter:e,count:(0,r.kJ)((0,r.t4)(this.arts,e)),splittedBy:t})}*split(e,t){this.add(e,"set");for(let e=this.stack.pop();e;e=this.stack.pop()){const{filter:n,count:r,splittedBy:a}=e;if(r<=t)yield n;else switch(a){case"set":this.splitBySet(n);break;case"id":this.splitByID(n,r,t);break;default:(0,s.UT)(a)}}}splitBySet(e){const t=(0,r.t4)(this.arts,e),n=$.Ex.map((e=>({slot:e,sets:new Set(t.values[e].map((e=>e.set)))}))).filter((({sets:e})=>e.size>1));if(!n.length)return this.add(e,"id");const{sets:s,slot:a}=n.reduce(((e,t)=>e.sets.size<t.sets.size?e:t));s.forEach((t=>this.add(Object.assign({},e,{[a]:{kind:"required",sets:new Set([t])}}),"set")))}splitByID(e,t,n){const s=(0,r.t4)(this.arts,e),{slot:a,length:o}=$.Ex.map((e=>({slot:e,length:s.values[e].length}))).filter((e=>e.length>1)).reduce(((e,t)=>e.length<t.length?e:t)),i=Math.ceil(t/n),c=Math.min(i,o),l=Array(c).fill(0).map((e=>new Set));s.values[a].forEach((({id:e},t)=>l[t%c].add(e))),l.forEach((t=>this.add(Object.assign({},e,{[a]:{kind:"id",ids:t}}),"id")))}}let S,N;onmessage=async e=>{try{await async function(e){const{data:t}=e,{command:n}=t;switch(n){case"split":for(const e of S.split(t.filter,t.maxIterateSize))postMessage({command:"iterate",filter:e}),await new Promise((e=>setTimeout(e)));break;case"iterate":N.compute(t.filter);break;case"threshold":return S.setThreshold(t.threshold),void N.setThreshold(t.threshold);case"finalize":{N.refresh(!0);const{builds:e,plotData:t}=N;postMessage({resultType:"finalize",builds:e,plotData:t});break}case"count":{const{exclusion:e,maxIterateSize:n}=t,s=N.arts,a=(0,r.ff)((0,r.vJ)(e,[...new Set(Object.values(s.values).flatMap((e=>e.map((e=>e.set)))))]),s);let o=0;for(const e of a)postMessage({command:"split",filter:e,maxIterateSize:n}),o+=(0,r.kJ)((0,r.t4)(s,e));postMessage({resultType:"count",count:o});break}case"setup":try{S=new k(t,(e=>postMessage(e)))}catch(e){S=new E(t,(e=>postMessage(e)))}N=new M(t,(e=>postMessage(e)));break;default:(0,s.UT)(n)}postMessage({resultType:"done"})}(e)}catch(e){postMessage({resultType:"err",message:e.message})}}},79924:(e,t,n)=>{n.d(t,{LG:()=>m,_B:()=>c,ff:()=>y,kJ:()=>x,s7:()=>w,sk:()=>g,t4:()=>b,vJ:()=>O});var s=n(40580),r=n(30597),a=n(97797),o=n(36893),i=n(41015);function c(e,t,n,s,r,a){let o=a;const i={pruneNodeRange:!0},c={pruneNodeRange:!0},f={reaffine:!0},h={pruneOrder:!0,pruneArtRange:!0,pruneNodeRange:!0};let m=0;for(;Object.values(o).some((e=>e))&&m++<20;){if(o.pruneOrder){delete o.pruneOrder;const e=u(n,s,r);n!==e&&(n=e,o=Object.assign({},o,i))}if(o.pruneArtRange){delete o.pruneArtRange;const s=p(e,n,t);n!==s&&(n=s,o=Object.assign({},o,c))}if(o.pruneNodeRange){delete o.pruneNodeRange;const t=d(e,n);e!==t&&(e=t,o=Object.assign({},o,f))}if(o.reaffine){delete o.reaffine;const{nodes:t,arts:s}=l(e,n);e===t&&n===s||(e=t,n=s,o=Object.assign({},o,h))}}return{nodes:e,arts:n}}function l(e,t,n=!1){const c=new Set,l=new Set;function u(e,t){t?c.add(e):e.operands.forEach((e=>c.has(e)&&l.add(e)))}const p=new Set;if((0,s.aD)(e,(e=>{}),(e=>{const{operation:t}=e;switch(t){case"read":p.add(e.path[1]),u(e,!0);break;case"add":u(e,e.operands.every((e=>c.has(e))));break;case"mul":{const t=e.operands.filter((e=>"const"!==e.operation));u(e,0===t.length||1===t.length&&c.has(t[0]));break}case"const":u(e,!0);break;case"res":case"threshold":case"sum_frac":case"max":case"min":u(e,!1);break;default:(0,i.UT)(t)}})),[...l].every((({operation:e})=>"read"===e||"const"===e))&&Object.keys(t.base).length===p.size)return{nodes:e,arts:t};let d=-1;function f(){for(;p.has(""+ ++d););return`${d}`}e.forEach((e=>c.has(e)&&l.add(e)));const h=[...l].filter((e=>"const"!==e.operation)),m=new Map(h.map((e=>[e,n||"read"!==e.operation||"dyn"!==e.path[0]?Object.assign({},(0,a.UF)(["dyn",`${f()}`]),{accu:"add"}):e])));function g(e){const t=(0,r.CG)([...m.keys()],{dyn:(0,i.xh)(e,(e=>(0,a.a9)(e)))},(e=>!0));return Object.fromEntries([...m.values()].map(((e,n)=>[e.path[1],t[n].value])))}const v={nodes:e=(0,s.uW)(e,(e=>{var t;return null!=(t=m.get(e))?t:e}),(e=>e)),arts:{base:g(t.base),values:(0,i.O)(o.eV,(e=>t.values[e].map((({id:e,set:t,values:n})=>({id:e,set:t,values:g(n)})))))}},b=Object.entries(g({}));for(const e of Object.values(v.arts.values))for(const{values:t}of e)for(const[e,n]of b)t[e]-=n;return v}function u(e,t,n){var s;let r=!1;const a=!(null!=(s=n.rainbow)&&s.length),c=Object.keys(e.base),l=new Set(Object.entries(n).filter((([e,t])=>t.length)).map((([e])=>e))),u=new Set(Object.entries(n).filter((([e,t])=>t.includes(2)&&!t.includes(4))).map((([e])=>e))),p=(0,i.O)(o.eV,(n=>{const s=e.values[n],o=s.filter((e=>{let n=0;return s.every((s=>{const r=c.every((t=>{var n,r;return(null!=(n=s.values[t])?n:0)>=(null!=(r=e.values[t])?r:0)})),o=c.some((t=>{var n,r;return(null!=(n=s.values[t])?n:0)>(null!=(r=e.values[t])?r:0)})),i=r&&(o||s.id>e.id),p=a&&!l.has(s.set)&&!u.has(e.set)||e.set===s.set;return i&&p&&n++,n<t}))}));return o.length!==s.length&&(r=!0),o}));return r?{base:e.base,values:p}:e}function p(e,t,n){const s=Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),r={arts:t};for(;;){const t=(0,i.O)(o.eV,(e=>h(r.arts.values[e]))),a=(0,i.O)(o.eV,(e=>f(Object.entries(t).map((t=>t[0]===e?s:t[1])).filter((e=>e)))));let c=!1;const l=(0,i.O)(o.eV,(t=>{const s=r.arts.values[t].filter((s=>{const r=f([h([s]),a[t]]),o=g(e,r);return e.every(((e,t)=>{var s;return o.get(e).max>=(null!=(s=n[t])?s:-1/0)}))}));return s.length!==r.arts.values[t].length&&(c=!0),s}));if(!c)break;r.arts={base:r.arts.base,values:l}}return r.arts}function d(e,t){const n=g(e,f([Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(t.values).map((e=>h(e)))]));return(0,s.uW)(e,(e=>{{const{min:t,max:s}=n.get(e);if(t===s)return(0,a.a9)(t)}const{operation:t}=e,s=e.operands.map((e=>n.get(e)));switch(t){case"threshold":{const[t,n,r,o]=s;if(t.min>=n.max)return e.operands[2];if(t.max<n.min)return e.operands[3];if(r.max===r.min&&o.max===o.min&&r.min===o.min&&isFinite(r.min))return(0,a.a9)(r.max);break}case"min":{const t=e.operands.filter(((e,t)=>{const n=s[t];return s.every((e=>n.min<=e.max))}));if(t.length<s.length)return(0,a.VV)(...t);break}case"max":{const t=e.operands.filter(((e,t)=>{const n=s[t];return s.every((e=>n.max>=e.min))}));if(t.length<s.length)return(0,a.Fp)(...t);break}}return e}),(e=>e))}function f(e){const t={};return e.forEach((e=>{Object.entries(e).forEach((([e,n])=>{t[e]?(t[e].min+=n.min,t[e].max+=n.max):t[e]=Object.assign({},n)}))})),t}function h(e){const t={};return e.length&&(Object.keys(e[0].values).filter((t=>e.every((e=>e.values[t])))).forEach((n=>t[n]={min:e[0].values[n],max:e[0].values[n]})),e.forEach((({values:e})=>{for(const[n,s]of Object.entries(e))t[n]?(t[n].max<s&&(t[n].max=s),t[n].min>s&&(t[n].min=s)):t[n]={min:0,max:s}}))),t}function m(e){return f([Object.fromEntries(Object.entries(e.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(e.values).map((e=>h(e)))])}function g(e,t){const n=new Map;return(0,s.aD)(e,(e=>{}),(e=>{var s;const{operation:a}=e,o=e.operands.map((e=>n.get(e)));let c;switch(a){case"read":if("dyn"!==e.path[0])throw new Error(`Found non-dyn path ${e.path} while computing range`);c=null!=(s=t[e.path[1]])?s:{min:0,max:0};break;case"const":c=v([e.value]);break;case"add":case"min":case"max":c={min:r.aj[a](o.map((e=>e.min))),max:r.aj[a](o.map((e=>e.max)))};break;case"res":c={min:r.aj[a]([o[0].max]),max:r.aj[a]([o[0].min])};break;case"mul":c=o.reduce(((e,t)=>v([e.min*t.min,e.min*t.max,e.max*t.min,e.max*t.max])));break;case"threshold":c=o[0].min>=o[1].max?o[2]:o[0].max<o[1].min?o[3]:v([],[o[2],o[3]]);break;case"sum_frac":{const[e,t]=o,n={min:e.min+t.min,max:e.max+t.max};c=n.min<=0&&n.max>=0?e.min<=0&&e.max>=0?{min:NaN,max:NaN}:{min:-1/0,max:1/0}:v([e.min/n.min,e.min/n.max,e.max/n.min,e.max/n.max]);break}default:(0,i.UT)(a)}n.set(e,c)})),n}function v(e,t=[]){const n=Math.max(...e,...t.map((e=>e.max)));return{min:Math.min(...e,...t.map((e=>e.min))),max:n}}function b(e,t){return{base:e.base,values:(0,i.O)(o.eV,(n=>{const s=t[n];switch(s.kind){case"id":return e.values[n].filter((e=>s.ids.has(e.id)));case"exclude":return e.values[n].filter((e=>!s.sets.has(e.set)));case"required":return e.values[n].filter((e=>s.sets.has(e.set)))}}))}}function w(e){let t=.01;let n=new Set(e.flatMap((e=>Object.values(e).map((e=>Math.round(e.plot/t))))));for(;n.size>1500;)t*=2,n=new Set([...n].map((e=>Math.round(e/2))));const s={};for(const n of e)for(const e of Object.values(n)){const n=Math.round(e.plot/t)*t;(!s[n]||s[n].value<e.value)&&(s[n]=e)}return s}function x(e){return o.eV.reduce(((t,n)=>t*e.values[n].length),1)}function*y(e,t){const n=(0,i.xh)(t.values,(e=>new Set(e.map((e=>e.set)))));e:for(const t of e){for(const[e,s]of Object.entries(t)){const t=n[e];switch(s.kind){case"required":if([...s.sets].every((e=>!t.has(e))))continue e;break;case"exclude":if([...t].every((e=>s.sets.has(e))))continue e}}yield t}}function k(e){return new Set(null!=e&&e.includes(2)?e.includes(4)?[0,1]:[0,1,4,5]:null!=e&&e.includes(4)?[0,1,2,3]:[0,1,2,3,4,5])}function*O(e,t){const n=[...new Set(t)],s=k(e.rainbow);let r=[];function a(e,t){if(!(0,i.w6)(t+1,4).some((t=>5!==e[t])))return(e=[...e])[t]=5,e.reduce(((e,t)=>6*e+t),0)}!function e(t,n,a){if(5!==t.length){for(const s of n)e([...t,s],n,a.filter((e=>e!==s)));e([...t,t.length],new Set([...n,t.length]),[...a,t.length])}else s.has(a.length)&&r.push(t)}([0],new Set([0]),[0]);for(let e=4;e>=0;e--){const t=new Map;for(const n of r){var c;const s=a(n,e);void 0!==s&&t.set(s,(null!=(c=t.get(s))?c:new Set(n.slice(0,e)).size+1)-1)}for(const[n,s]of t.entries())if(0===s){const t=[...r.find((t=>a(t,e)===n))];t[e]=5,r=r.filter((t=>a(t,e)!==n)),r.push(t)}}const l={kind:"exclude",sets:new Set},u=(0,i.O)(o.eV,(e=>l)),p=Object.assign({},(0,i.xh)(e,(e=>0)),(0,i.O)(n,(e=>0))),d=(0,i.xh)(e,k);function*f(e){const t=new Set,s=[];let r=[];for(const t of e)r.push([]),5===t?s.push(r.length-1):r[t].push(r.length-1);r=r.filter((e=>e.length)).sort(((e,t)=>t.length-e.length));let a=s.length;function*c(e){const t=s.length-e,r=[],a=[],l=[];let f=0;for(const e of n){const n=d[e],s=p[e];n&&((0,i.w6)(1,t).every((e=>!n.has(s+e)))?l.push(e):n.has(s)?(0,i.w6)(0,t).some((e=>!n.has(s+e)))&&r.push(e):(f+=[...n].find((e=>e>s))-s,a.push(e)))}if(!(f>t))if(e!==s.length)if(f!==t){for(const t of[...r,...a])p[t]++,u[o.eV[s[e]]]={kind:"required",sets:new Set([t])},yield*c(e+1),p[t]--;u[o.eV[s[e]]]={kind:"exclude",sets:new Set([...a,...l,...r])},yield*c(e+1)}else for(const t of a)p[t]++,u[o.eV[s[e]]]={kind:"required",sets:new Set([t])},yield*c(e+1),p[t]--;else yield Object.assign({},u)}yield*function*e(s){if(s===r.length)return yield*c(0);for(const c of n){if(t.has(c))continue;const n=r[s].length,f=d[c];let h=0;var l;if(f&&!f.has(n))if(h=(null!=(l=(0,i.w6)(n+1,5).find((e=>f.has(e))))?l:6)-n,h>a)continue;t.add(c),p[c]=r[s].length,r[s].forEach((e=>u[o.eV[e]]={kind:"required",sets:new Set([c])})),a-=h,yield*e(s+1),a+=h,p[c]=0,t.delete(c)}}(0)}for(const e of r)yield*f(e)}},36893:(e,t,n)=>{n.d(t,{eV:()=>r});var s=n(60467);const r=["flower","plume","sands","goblet","circlet"],a=(s.Kn,["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"]);s.Kn,s.Kn,s.j4,s.X7,s.ie,s.oK,s.Xt},41015:(e,t,n)=>{n.d(t,{Hm:()=>s,O:()=>r,Og:()=>u,UT:()=>l,Uq:()=>a,w6:()=>c,xh:()=>o});function s(e,t){if(e&&t)return!Array.isArray(t)&&console.error(t),t.reduce(((e,t)=>null==e?void 0:e[t]),e)}function r(e,t){return Object.fromEntries(e.map(((e,n)=>[e,t(e,n)])))}function a(e,t){return Object.fromEntries(e.map(((e,n)=>t(e,n))))}function o(e,t){return Object.fromEntries(Object.entries(e).map((([e,n],s)=>[e,t(n,e,s)])))}const i=function*(e,t){for(let n=e;n<=t;n++)yield n};function c(e,t){return[...i(e,t)]}function l(e){throw new Error(`Should not reach this with value ${e}`)}function u(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,[t]].flat()))))),[[]])}},60467:(e,t,n)=>{n.d(t,{Ex:()=>r,oK:()=>a.oK,Xt:()=>a.Xt,X7:()=>a.X7,ie:()=>a.ie,j4:()=>a.j4,Kn:()=>s.Kn});var s=n(10533);const r=["flower","plume","sands","goblet","circlet"];var a=n(7664)}},s={};function r(e){var t=s[e];if(void 0!==t)return t.exports;var a=s[e]={exports:{}};return n[e](a,a.exports,r),a.exports}r.m=n,r.x=()=>{var e=r.O(void 0,[592],(()=>r(28228)));return e=r.O(e)},e=[],r.O=(t,n,s,a)=>{if(!n){var o=1/0;for(u=0;u<e.length;u++){for(var[n,s,a]=e[u],i=!0,c=0;c<n.length;c++)(!1&a||o>=a)&&Object.keys(r.O).every((e=>r.O[e](n[c])))?n.splice(c--,1):(i=!1,a<o&&(o=a));if(i){e.splice(u--,1);var l=s();void 0!==l&&(t=l)}}return t}a=a||0;for(var u=e.length;u>0&&e[u-1][2]>a;u--)e[u]=e[u-1];e[u]=[n,s,a]},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.f={},r.e=e=>Promise.all(Object.keys(r.f).reduce(((t,n)=>(r.f[n](e,t),t)),[])),r.u=e=>"common.e2fe9b8b013983f2.js",r.miniCssF=e=>{},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.j=228,(()=>{var e;r.g.importScripts&&(e=r.g.location+"");var t=r.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");n.length&&(e=n[n.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})(),(()=>{var e={228:1};r.f.i=(t,n)=>{e[t]||importScripts(r.p+r.u(t))};var t=self.webpackChunk=self.webpackChunk||[],n=t.push.bind(t);t.push=t=>{var[s,a,o]=t;for(var i in a)r.o(a,i)&&(r.m[i]=a[i]);for(o&&o(r);s.length;)e[s.pop()]=1;n(t)}})(),t=r.x,r.x=()=>r.e(592).then(t);r.x()})();